import 'package:deriv_chart/deriv_chart.dart';
import 'package:deriv_chart/src/add_ons/drawing_tools_ui/callbacks.dart';
import 'package:deriv_chart/src/add_ons/drawing_tools_ui/drawing_tool_item.dart';
import 'package:deriv_chart/src/deriv_chart/chart/data_visualization/drawing_tools/drawing_tool_label_painter.dart';
import 'package:deriv_chart/src/deriv_chart/chart/data_visualization/drawing_tools/data_model/drawing_paint_style.dart';
import 'package:deriv_chart/src/deriv_chart/chart/data_visualization/drawing_tools/data_model/drawing_pattern.dart';
import 'package:deriv_chart/src/deriv_chart/chart/data_visualization/drawing_tools/data_model/edge_point.dart';
import 'package:deriv_chart/src/deriv_chart/chart/data_visualization/drawing_tools/data_model/point.dart';
import 'package:deriv_chart/src/deriv_chart/drawing_tool_chart/interactive_layer.dart';
import 'package:flutter/material.dart';

/// Drawing tools config
@immutable
abstract class DrawingToolConfig extends AddOnConfig {
  /// Initializes
  const DrawingToolConfig({
    required this.configId,
    required this.drawingData,
    // TODO(Bahar-Deriv): Move edgePoints to drawingData.
    required this.edgePoints,
    bool isOverlay = true,
    super.number,
  }) : super(isOverlay: isOverlay);

  /// Creates a concrete drawing tool config from JSON.
  factory DrawingToolConfig.fromJson(Map<String, dynamic> json) {
    if (!json.containsKey(nameKey)) {
      throw ArgumentError.value(json, 'json', 'Missing drawing tool name.');
    }

    switch (json[nameKey]) {
      case ChannelDrawingToolConfig.name:
        return ChannelDrawingToolConfig.fromJson(json);
      case ContinuousDrawingToolConfig.name:
        return ContinuousDrawingToolConfig.fromJson(json);
      case FibfanDrawingToolConfig.name:
        return FibfanDrawingToolConfig.fromJson(json);
      case HorizontalDrawingToolConfig.name:
        return HorizontalDrawingToolConfig.fromJson(json);
      case LineDrawingToolConfig.name:
        return LineDrawingToolConfig.fromJson(json);
      case LineDrawingToolConfigMobile.name:
        return LineDrawingToolConfigMobile.fromJson(json);
      case RayDrawingToolConfig.name:
        return RayDrawingToolConfig.fromJson(json);
      case RectangleDrawingToolConfig.name:
        return RectangleDrawingToolConfig.fromJson(json);
      case TrendDrawingToolConfig.name:
        return TrendDrawingToolConfig.fromJson(json);
      case VerticalDrawingToolConfig.name:
        return VerticalDrawingToolConfig.fromJson(json);

      // Add new drawing tools here.
      default:
        throw ArgumentError.value(
            json, 'json', 'Unidentified drawing tool name.');
    }
  }

  /// Drawing tool data.
  final DrawingData? drawingData;

  /// Drawing tool edge points.
  final List<EdgePoint> edgePoints;

  /// Drawing tool config id.
  final String? configId;

  /// Key of drawing tool name property in JSON.
  static const String nameKey = 'name';

  /// Key of drawing tool config id property in JSON.
  static String configIdKey = 'configId';

  /// Returns back the [InteractableDrawing] instance of this drawing tool.
  InteractableDrawing getInteractableDrawing() {
    throw UnimplementedError('getInteractableDrawing() is not implemented.');
  }

  /// Creates a copy of this object.
  DrawingToolConfig copyWith({
    String? configId,
    DrawingData? drawingData,
    LineStyle? lineStyle,
    LineStyle? fillStyle,
    DrawingPatterns? pattern,
    List<EdgePoint>? edgePoints,
    bool? enableLabel,
    int? number,
  });

  /// Creates drawing tool.
  DrawingToolItem getItem(
    UpdateDrawingTool updateDrawingTool,
    VoidCallback deleteDrawingTool,
  );

  /// Create label painter for the drawing tool.
  DrawingToolLabelPainter? getLabelPainter({
    required Point startPoint,
    required Point endPoint,
  }) =>
      null;
}

/// The class that will be generated by the drawing tool config instance when
/// they are created or the saved ones that are loaded from storage.
/// The information from this class (its subclasses) will be used to draw the
/// tool on the chart.
/// It will keep the latest state of the drawing tool as the user interacts
/// with the tools in the runtime.
/// During the time that user interacts with a tool. by some debounce mechanism
/// This class will update the config which is supposed to be saved in the storage.
abstract class InteractableDrawing {
  /// Initializes [InteractableDrawing].
  InteractableDrawing({required this.config});

  static const double _hitTestMargin = 16;

  /// The margin for hit testing.
  double get hitTestMargin => _hitTestMargin;

  /// The drawing tool config.
  final DrawingToolConfig config;

  /// Returns `true` if the drawing tool is hit by the given offset.
  bool hitTest(Offset offset, EpochToX epochToX, QuoteToY quoteToY);

  /// Called when the drawing tool is dragged and updates the drawing position
  /// properties based on the dragging [details].
  ///
  /// Each drawing will know how to handle and update itself accordingly based
  /// on where the dragging position is like if it's dragging a point or a line
  /// of the tool.
  void onDragUpdate(
    DragUpdateDetails details,
    EpochFromX epochFromX,
    QuoteFromY quoteFromY,
    EpochToX epochToX,
    QuoteToY quoteToY,
  );

  /// Paints the drawing tool on the chart.
  void paint(
    Canvas canvas,
    Size size,
    EpochToX epochToX,
    QuoteToY quoteToY,
    AnimationInfo animationInfo,
    IsDrawingSelected isDrawingSelected,
  );
}

/// Interactable drawing for line drawing tool.
class LineInteractableDrawing extends InteractableDrawing {
  /// Initializes [LineInteractableDrawing].
  LineInteractableDrawing({
    required LineDrawingToolConfig config,
    required this.startPoint,
    required this.endPoint,
  }) : super(config: config);

  /// Start point of the line.
  EdgePoint startPoint;

  /// End point of the line.
  EdgePoint endPoint;

  @override
  bool hitTest(Offset offset, EpochToX epochToX, QuoteToY quoteToY) {
    // Convert start and end points from epoch/quote to screen coordinates
    final Offset startOffset = Offset(
      epochToX(startPoint.epoch),
      quoteToY(startPoint.quote),
    );
    final Offset endOffset = Offset(
      epochToX(endPoint.epoch),
      quoteToY(endPoint.quote),
    );

    // Calculate line length
    final double lineLength = (endOffset - startOffset).distance;

    // If line length is too small, treat it as a point
    if (lineLength < 1) {
      return (offset - startOffset).distance <= hitTestMargin;
    }

    // Calculate perpendicular distance from point to line
    // Formula: |((y2-y1)x - (x2-x1)y + x2y1 - y2x1)| / sqrt((y2-y1)² + (x2-x1)²)
    final double distance = ((endOffset.dy - startOffset.dy) * offset.dx -
                (endOffset.dx - startOffset.dx) * offset.dy +
                endOffset.dx * startOffset.dy -
                endOffset.dy * startOffset.dx)
            .abs() /
        lineLength;

    // Check if point is within the line segment (not just the infinite line)
    final double dotProduct =
        (offset.dx - startOffset.dx) * (endOffset.dx - startOffset.dx) +
            (offset.dy - startOffset.dy) * (endOffset.dy - startOffset.dy);

    final bool isWithinRange =
        dotProduct >= 0 && dotProduct <= lineLength * lineLength;

    final result = isWithinRange && distance <= hitTestMargin;
    // Return true if within range and close enough to line (8 pixel margin)
    return result;
  }

  @override
  void paint(
    Canvas canvas,
    Size size,
    EpochToX epochToX,
    QuoteToY quoteToY,
    AnimationInfo animationInfo,
    IsDrawingSelected isDrawingSelected,
  ) {
    final config = this.config as LineDrawingToolConfig;
    final LineStyle lineStyle = config.lineStyle;
    final DrawingPaintStyle paintStyle = DrawingPaintStyle();

    final Offset startOffset =
        Offset(epochToX(startPoint.epoch), quoteToY(startPoint.quote));
    final Offset endOffset =
        Offset(epochToX(endPoint.epoch), quoteToY(endPoint.quote));

    // Check if this drawing is selected
    final bool isCurrentlySelected = isDrawingSelected(this);

    // Use glowy paint style if selected, otherwise use normal paint style
    final Paint paint = isCurrentlySelected
        ? paintStyle.glowyLinePaintStyle(lineStyle.color, lineStyle.thickness)
        : paintStyle.linePaintStyle(lineStyle.color, lineStyle.thickness);

    canvas.drawLine(startOffset, endOffset, paint);

    // Draw endpoints with glowy effect if selected
    if (isCurrentlySelected) {
      const double markerRadius = 5;
      canvas
        ..drawCircle(
          startOffset,
          markerRadius,
          paintStyle.glowyCirclePaintStyle(lineStyle.color),
        )
        ..drawCircle(
          endOffset,
          markerRadius,
          paintStyle.glowyCirclePaintStyle(lineStyle.color),
        );
    }
  }

  @override
  void onDragUpdate(
    DragUpdateDetails details,
    EpochFromX epochFromX,
    QuoteFromY quoteFromY,
    EpochToX epochToX,
    QuoteToY quoteToY,
  ) {
    // Get the drag delta in screen coordinates
    final Offset delta = details.delta;

    // Convert start and end points to screen coordinates
    final Offset startOffset = Offset(
      epochToX(startPoint.epoch),
      quoteToY(startPoint.quote),
    );
    final Offset endOffset = Offset(
      epochToX(endPoint.epoch),
      quoteToY(endPoint.quote),
    );

    // Apply the delta to get new screen coordinates
    final Offset newStartOffset = startOffset + delta;
    final Offset newEndOffset = endOffset + delta;

    // Convert back to epoch and quote coordinates
    final int newStartEpoch = epochFromX(newStartOffset.dx);
    final double newStartQuote = quoteFromY(newStartOffset.dy);
    final int newEndEpoch = epochFromX(newEndOffset.dx);
    final double newEndQuote = quoteFromY(newEndOffset.dy);

    // Update the start and end points
    startPoint = EdgePoint(
      epoch: newStartEpoch,
      quote: newStartQuote,
    );
    endPoint = EdgePoint(
      epoch: newEndEpoch,
      quote: newEndQuote,
    );

    // Note: The actual config update should be handled by the InteractiveLayer
    // which has access to the Repository. This method only updates the local
    // startPoint and endPoint properties, which will be reflected in the drawing.
    //
    // The InteractiveLayer should periodically check if the selected drawing's
    // points have changed and update the config in the repository accordingly.
  }
}
